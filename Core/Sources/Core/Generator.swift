// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
//  Created by Sam Deane on 19/02/20.
//  All code (c) 2020 - present day, Elegant Chaos Limited.
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

import Foundation
import Bundles

public class Generator {
    public struct Output {
        public let repo: Repo
        public let source: String
        public let data: Data
        public let header: String
        public let delimiter: String
    }

    // See https://github.com/actions/virtual-environments for available Xcode versions.
    // See https://swiftly.dev/swift-versions for Xcode/Swift version mapping.
    
    public let compilers = [
        Compiler("swift-50", name: "Swift 5.0", short: "5.0", linux: "swift:5.0", mac: .xcode(version: "11.2.1", image: "macos-10.15")),
        Compiler("swift-51", name: "Swift 5.1", short: "5.1", linux: "swift:5.1", mac: .xcode(version: "11.3.1", image: "macos-10.15")),
        Compiler("swift-52", name: "Swift 5.2", short: "5.2", linux: "swift:5.2.3-bionic", mac: .xcode(version: "11.7", image: "macos-11")),
        Compiler("swift-53", name: "Swift 5.3", short: "5.3", linux: "swift:5.3.3-bionic", mac: .xcode(version: "12.4", image: "macos-11")),
        Compiler("swift-54", name: "Swift 5.4", short: "5.4", linux: "swift:5.4.2-bionic", mac: .xcode(version: "12.5.1", image: "macos-11")),
        Compiler("swift-55", name: "Swift 5.5", short: "5.5", linux: "swift:5.5.3-bionic", mac: .xcode(version: "13.0", image: "macos-11")),
        
        // https://download.swift.org/swift-5.6.1-release/xcode/swift-5.6.1-RELEASE/swift-5.6.1-RELEASE-osx.pkg
        Compiler("swift-56", name: "Swift 5.6", short: "5.6", linux: "swift:5.6.1-bionic", mac: .toolchain(version: "13.2.1", branch: "swift-5.6.1-RELEASE", image: "macos-11")),

        // https://download.swift.org/development/xcode/swift-DEVELOPMENT-SNAPSHOT-2022-03-22-a/swift-DEVELOPMENT-SNAPSHOT-2022-03-22-a-osx.pkg
        Compiler("swift-nightly", name: "Swift Development Nightly", short: "dev", linux: "swiftlang/swift:nightly", mac: .toolchain(version: "13.2.1", branch: "development", image: "macos-11")),
    ]
    
    public let platforms = [
        Platform("macOS", name: "macOS"),
        Platform("iOS", name: "iOS", xcodeDestination: "iPhone 11"),
        Platform("tvOS", name: "tvOS", xcodeDestination: "Apple TV"),
        Platform("watchOS", name: "watchOS", xcodeDestination: "Apple Watch Series 5 - 44mm"),
        Platform("linux", name: "Linux"),
    ]
    
    public let configurations = [
        Option("debug", name: "Debug"),
        Option("release", name: "Release")
    ]
    
    public let general = [
        Option("test", name: "Run Tests"),
        Option("firstlast", name: "Check Oldest and Newest Swift Only"),
        Option("notify", name: "Post Notifications"),
        Option("upload", name: "Upload Logs"),
        Option("header", name: "Add a header to README.md")
    ]
    
    public init() {
    }
    
    func enabledCompilers(for repo: Repo) -> [Compiler] {
        let options = repo.settings.options
        var enabled: [Compiler] = []
        for swift in compilers {
            if options.contains(swift.id) {
                enabled.append(swift)
            }
        }
        return enabled
    }
    
    func enabledPlatforms(for repo: Repo) -> [Platform] {
        let options = repo.settings.options
        var jobs: [Platform] = []
        for platform in platforms {
            if options.contains(platform.id) {
                jobs.append(platform)
            }
        }
        
        return jobs
    }

    func enabledConfigs(for repo: Repo) -> [String] {
        let options = repo.settings.options
        return configurations.filter({ options.contains($0.id) }).map({ $0.name })
    }

    public func toggleSet(for options: [Option], in settings: WorkflowSettings) -> [Bool] {
        var toggles: [Bool] = []
        for option in options {
            toggles.append(settings.options.contains(option.id))
        }
        return toggles
    }
    
    public func enabledIdentifiers(for options: [Option], toggleSet toggles: [Bool]) -> [String] {
        var identifiers: [String] = []
        for n in 0 ..< options.count {
            if toggles[n] {
                identifiers.append(options[n].id)
            }
        }
        return identifiers
    }
    
    func generateYAML(for repo: Repo, platforms: [Platform], compilers: [Compiler], application: BundleInfo) -> String {
        
        var source =
         """
         # --------------------------------------------------------------------------------
         # This workflow was automatically generated by Action Status \(application.fullVersionString).
         # (see https://actionstatus.elegantchaos.com for more details)
         # --------------------------------------------------------------------------------
         
         name: \(repo.workflow)
         
         on: [push, pull_request]
         
         jobs:
         
         """
         
        var xcodePlatforms: [Platform] = []
        for platform in platforms {
            if platform.xcodeDestination == nil {
                source.append(platform.yaml(repo: repo, compilers: compilers, configurations: enabledConfigs(for: repo)))
            } else {
                xcodePlatforms.append(platform)
            }
        }
        
        if xcodePlatforms.count > 0 {
            let name = xcodePlatforms.map({ $0.name }).joined(separator: "/")
            let xcodePlatform = Platform("xcode", name: name, subPlatforms: xcodePlatforms)
            source.append(xcodePlatform.yaml(repo: repo, compilers: compilers, configurations: enabledConfigs(for: repo)))
        }
        
        return source
    }
     
     func generateHeader(for repo: Repo, platforms: [Platform], compilers: [Compiler], application: BundleInfo) -> (String, String) {
         var header = ""
         let headerDelimiter = "[comment]: <> (End of ActionStatus Header)\n\n"
         if repo.settings.header {
             let platformNames = platforms.map({ $0.name }).joined(separator: ", ")
             let platformIDs = platforms.map({ $0.name })
             let swiftBadges = compilers.map({ "![swift \($0.short) shield]" }).joined(separator: " ")
             let swiftShields = compilers.map({ "[swift \($0.short) shield]: \(repo.imgShieldURL(for: $0)) \"Swift \($0.short)\"" }).joined(separator: "\n")

             header += """
                 [comment]: <> (Header Generated by ActionStatus \(application.versionString) - \(application.build))
                 
                 [![Test results][tests shield]][actions] [![Latest release][release shield]][releases] [\(swiftBadges)][swift] ![Platforms: \(platformNames)][platforms shield]

                 [release shield]: \(repo.imgShieldURL(for: .release))
                 [platforms shield]: \(repo.imgShieldURL(forPlatforms: platformIDs)) "\(platformNames)"
                 [tests shield]: \(repo.githubURL(for: .badge("")))
                 \(swiftShields)

                 [swift]: https://swift.org
                 [releases]: \(repo.githubURL(for: .releases))
                 [actions]: \(repo.githubURL(for: .actions))

                 \(headerDelimiter)
                 """
         }
         
         return (header, headerDelimiter)
     }

    public func generateWorkflow(for repo: Repo, application: BundleInfo) -> Output? {
        let supportedCompilers = enabledCompilers(for: repo)
        var compilersToTest = supportedCompilers
        if repo.settings.options.contains("firstlast") && (supportedCompilers.count > 0) {
            compilersToTest = [supportedCompilers.first!]
            let last = supportedCompilers.last!
            if !compilersToTest.contains(last) {
                compilersToTest.append(last)
            }
        }
        
        let platforms = enabledPlatforms(for: repo)

        let source = generateYAML(for: repo, platforms: platforms, compilers: compilersToTest, application: application)
        let (header, delimiter) = generateHeader(for: repo, platforms: platforms, compilers: supportedCompilers, application: application)
        
        guard let data = source.data(using: .utf8) else { return nil }
        return Output(repo: repo, source: source, data: data, header: header, delimiter: delimiter)
    }
    
}
